package openaigo

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

// Client is a client for the OpenAI Completions API.
type Client struct {
	// HTTPClient is the HTTP client to use for making requests.
	HTTPClient *http.Client

	// APIKey is the API key to use for authenticating requests.
	APIKey string

	// Endpoint is the base URL of the Completions API.
	Endpoint string
}

// CompletionRequest is a request to the OpenAI Completions API.
type CompletionRequest struct {
	// Prompt is the text that the API will use to generate completions.
	Prompt string

	// Model is the name of the model to use.
	Model string

	// MaxTokens is the maximum number of tokens (words) that the API should generate.
	MaxTokens int

	// Temperature is a value that controls the randomness of the generated text.
	Temperature float64
}

// CompletionResponse is a response from the OpenAI Completions API.
type CompletionResponse struct {
	// ID is a unique identifier for the request.
	ID string

	// Model is the name of the model that was used to generate the completions.
	Model string

	// Prompt is the text that the API used to generate the completions.
	Prompt string

	// Completions is a list of completions generated by the API.
	Completions []string

	// Tokens is a list of tokens (words) used to generate the completions.
	Tokens []string
}

// Complete sends a request to the OpenAI Completions API and returns the response.
func (c *Client) Complete(ctx context.Context, req *CompletionRequest) (*CompletionResponse, error) {
	// Set up the HTTP request.
	httpReq, err := http.NewRequest("POST", c.Endpoint, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Authorization", fmt.Sprintf("Bearer %s", c.APIKey))

	// Set the request body.
	data := map[string]interface{}{
		"prompt":      req.Prompt,
		"model":       req.Model,
		"max_tokens":  req.MaxTokens,
		"temperature": req.Temperature,
	}
	body, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}
	httpReq.Body = ioutil.NopCloser(bytes.NewBuffer(body))

	// Send the request and handle the response.
	httpResp, err := c.HTTPClient.Do(httpReq.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer httpResp.Body.Close()

	// Read and parse the response body.
	respBody, err := ioutil.ReadAll(httpResp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}
	var resp CompletionResponse
	err = json.Unmarshal(respBody, &resp)
	if err != nil {
		return nil, fmt.Errorf("failed to parse response body: %w", err)
	}

	return &resp, nil
}
